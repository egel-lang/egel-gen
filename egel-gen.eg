#!/usr/bin/env egel
# Egel combinator documentation extractor.

import "prelude.eg"
import "os.ego"
import "fs.ego"
import "regex.ego"

using System
using List

# constants with all source code locations

val builtins = { 
	"egel/src/builtin_system.cpp",
	"egel/src/builtin_math.cpp",
	"egel/src/builtin_eval.cpp",
	"egel/src/builtin_string.cpp",
	"egel/src/builtin_eval.cpp",
	"egel/src/builtin_thread.cpp",
	"egel/src/builtin_process.cpp"
}

val modules = {
	"egel/lib/os/os.cpp",
	"egel/lib/fs/fs.cpp",
	"egel/lib/regex/regex.cpp",
	"egel/lib/random/random.cpp"
}

val preludes = {
	"egel/include/prelude.eg"
}

val sources = builtins ++ (modules ++ preludes)

# read in sources

data source

def file_check =
    [ FN -> 
	if OS:exists FN 
	then print (format "reading file {}\n" FN) 
	else throw (format "didn't find file {}" FN) ]

def file_readlines =
    [ FS ->
        let L = OS:read_line FS in
        if OS:eof FS then nil else cons L (file_readlines FS) ]

def file_input =
    [ FN ->
        file_check FN;
        source FN (file_readlines (OS:open FN)) ]

# regex to match against a documentation comment

def regex_comment = "\\/\\/##.*"

val regex_pattern = Regex:compile regex_comment

def filter_doc =
    [ (source FN LL) ->
        source FN (filter (Regex:match regex_pattern) LL) ]

# tying it all together

def main =
    let DD = map file_input sources in
    let DD = map filter_doc DD in
        DD
